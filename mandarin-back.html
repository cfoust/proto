<div class="headword" id="head"></div>
<div class="stroke" id="stroke" style="display:none">{{Headword}}</div>

<div class="redbutton" style="float: left" ontouchstart="switchStroke()">筆順</div>

<div style="display: none" id="data">{{Data}}</div>
<div style="display: none">{{Sound}}</div>

<a id="sound" class="redbutton">
<div class="redbutton" style="float: right">
	<div class="play"></div>
</div>
</a>

<div class="content" id="def">asddasd</div>

<script>


if (!window.proto) {
	window.proto = {
		renderDefinition: function(data) {
      const defs = data[14].split('/');

			var text = "";

      text += `<a href="plecoapi://x-callback-url/s?q=${data[0]}">Pleco</a>`;

			// Parse over each definition
			for (let j = 0; j < defs.length; j++) {
				let definition = defs[j], meaning = "";

				meaning += "<span class='meaning-number'>" + (j + 1) + ".</span>";
				meaning += "<span class='meaning-meaning'>" + definition;
				meaning += "</span>";

				text += "<div class='meaning-definition'>" + meaning + "</div>";
			}

			return text;
		},

		renderPinYin: function(data) {
      const original = data[0];
      const pinyin = data[2];

			const rubify = function(character, reading) {
				return "<ruby><rb>" + character + "</rb><rp>(</rp><rt>" + reading + "</rt><rp>)</rp></ruby>";
			};

      // Sometimes there are pronunciation variations.
      // Just take the first one.
      if (pinyin.includes('/')) {
        return rubify(original, pinyin.split('/')[0]);
      }

      const parts = pinyin.split(' ');
      return original
        .split('')
        .map((v, i) => rubify(v, parts[i]))
        .join('');
		},

    getData: function(dataString) {
      const deFormat = a => a.split("'").join('"')
      if (!dataString.includes('"')) {
        return JSON.parse(deFormat(dataString))
      }

      const parts = dataString.split('"')
      const definition = parts[1]
      const rest = JSON.parse(deFormat(parts[0].slice(0, -2) + ']'))
      return rest.concat([definition])
    },

		/**
		 * Renders information on a word to the DOM, prioritizing the most
		 * common reading.
		 * @param  {String} data    JSON array.
		 * @return {None}           Just modifies the DOM; no return value.
		 */
		render: function(headword, dataString) {
			const head   = document.getElementById("head");
			const stroke = document.getElementById("stroke");
		  const def    = document.getElementById("def");
      def.innerHTML = dataString;
			const data   = this.getData(dataString);

      head.innerHTML = this.renderPinYin(data);
      stroke.innerHTML = data[0];
			def.innerHTML = this.renderDefinition(data);;
		}
	};

	function switchStroke() {
		var head   = document.getElementById("head"),
			stroke = document.getElementById("stroke");

		if (head.style.display == "none") {
			stroke.style.display = "none";
			head.style.display = "block";
		} else {
			head.style.display = "none";
			stroke.style.display = "block";
		}
	}
}

proto.render('{{Headword}}', document.getElementById("data").innerHTML);

</script>
