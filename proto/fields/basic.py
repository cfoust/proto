import peewee, datetime, zlib, base64


class FieldType:
    """ Name as it will show up in Anki for this field. Does not need to be unique."""
    anki_name = "Basic Field"

    """ Encapsulates the text that is generated by this class. Mostly for convenience."""
    html = """<div class="content center">%s</div>"""

    # Text to be appended to the card CSS for this field.
    css = ""

    # Text to be appended to the card JS for this field.
    js = ""

    order = -1

    front = False

    def __init__(self,front = False):
        self.front = front

    """Always generated for the basic class, no caching. The pull method just takes the word input and returns the formatted output for the desired field."""
    def pull(self,word):
        return word

"""This makes it so you can use multiple field generators for a given field."""
class PriorityFieldType(FieldType):

    def __init__(self,fields):
        assert len(fields) > 0
        self.fields = fields

    def pull(self,word):
        for subfield in self.fields:
            result = subfield.pull(word)
            if result != None:
                return result
        return None

dbproxy = peewee.Proxy()

class CachedInfo(peewee.Model):
    db_name = peewee.CharField()
    timestamp = peewee.DateTimeField()
    lemma = peewee.CharField()
    data = peewee.TextField()
    compressed = peewee.BooleanField()
    class Meta:
        database = dbproxy

""" Number of characters after which we compress. """
COMPRESSION_CUTOFF = 1024
class Cacher:
    def __init__(self,pathToDb,identifier):
        # Makes a connection to the provided sqlite db
        sqlitedb = peewee.SqliteDatabase(pathToDb)
        sqlitedb.connect()
        dbproxy.initialize(sqlitedb)

        self.db = sqlitedb
        self.db.create_tables([CachedInfo],safe=True)
        self.identifier = identifier

    def _getRow(self,word):
        return CachedInfo.get(CachedInfo.db_name == self.identifier,
                              CachedInfo.lemma == word)

    """ Checks whether some data exists for a word. """
    def exists(self,word):
        try:
            info = self._getRow(word)
            return True
        except peewee.DoesNotExist:
            return False

    """ Pulls some cached info from the DB. """
    def retrieve(self,word):
        try:
            info = self._getRow(word)
            if info.compressed:
                return zlib.decompress(base64.b64decode(info.data))
            else:
                return info.data
        except peewee.DoesNotExist:
            return None

    """ This can create new entries or update old ones."""
    def store(self,word,data):

        compressed = len(data) > COMPRESSION_CUTOFF
        if compressed:
            data = base64.b64encode(zlib.compress(data))

        if self.exists(word):
            info = self._getRow(word)
            info.compressed = compressed
            info.data = data
            info.timestamp = datetime.datetime.now()
            info.save()
        else:
            info = CachedInfo.create(db_name = self.identifier,
                                     timestamp = datetime.datetime.now(),
                                     lemma = word,
                                     data = data,
                                     compressed = compressed)
    def storeMany(self,data):
        transformed = []

        for word,datum in data:
            compressed = len(datum) > COMPRESSION_CUTOFF
            transformed.append({
                'compressed': compressed,
                'data': datum,
                'timestamp': datetime.datetime.now(),
                'db_name': self.identifier,
                'lemma': word
            })

        with self.db.atomic():
            CachedInfo.insert_many(transformed).execute()


    def delete(self,word):
        info = self._getRow(word)
        info.delete_instance()

    def clear(self):
        CachedInfo.delete().where(CachedInfo.db_name == self.identifier).execute()

    def clearForWord(self,word):
        CachedInfo.delete().where(CachedInfo.db_name == self.identifier, CachedInfo.lemma == word).execute()

    def rename(self,newname):
        CachedInfo.update(db_name=newname).where(CachedInfo.db_name == self.identifier).execute()
        self.identifier = newname



class CacheableFieldType(FieldType):
    """ Just for cached fields, how the name will show up in the DB. Needs to be unique or will pull other data."""
    db_name = "cacheable-default"

    def __init__(self,pathToDb):
        self.cacher = Cacher(pathToDb, self.db_name)

    def pull(self,word):
        if self.cacher.exists(word):
            result = self.cacher.retrieve(word)
            return result
        else:
            result = self.generate(word)

            if not result:
                return None

            self.cacher.store(word,result)
            return result

    """ Generates the resulting string given the input. May be data intensive, because this is cacheable. """
    def generate(self,word):
        return word

